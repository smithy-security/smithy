package testing

import (
	"fmt"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"google.golang.org/protobuf/encoding/protojson"

	ocsffindinginfo "github.com/smithy-security/smithy/sdk/gen/ocsf_ext/finding_info/v1"
	ocsf "github.com/smithy-security/smithy/sdk/gen/ocsf_schema/v1"
)

// AssertVulnerabilityFindingIsValid uses testify assertions to validate all required fields of a finding.
// It uses `require` for critical checks that prevent further validation and `assert` for all other checks.
func AssertVulnerabilityFindingIsValid(t *testing.T, finding *ocsf.VulnerabilityFinding) bool {
	// VulnerabilityFinding and FindingInfo are essential
	require.NotNil(t, finding, "VulnerabilityFinding should not be nil")
	findingInfo := finding.GetFindingInfo()
	require.NotNil(t, findingInfo, "FindingInfo is required")

	assert.NotEmpty(t, findingInfo.GetUid(), "FindingInfo.Uid is required")
	assert.NotEmpty(t, findingInfo.GetTitle(), "FindingInfo.Title is required")

	dataSourcesJson := findingInfo.GetDataSources()
	require.Len(t, dataSourcesJson, 1, "Exactly one 'DataSource' JSON string is required")
	require.NotEmpty(t, dataSourcesJson[0], "The 'DataSource' JSON string cannot be empty")

	dataSource := &ocsffindinginfo.DataSource{}
	require.NoError(t, protojson.Unmarshal([]byte(dataSourcesJson[0]), dataSource), "Failed to protojson.Unmarshal DataSource")

	uri := dataSource.GetUri()
	if assert.NotNil(t, uri, "DataSource.Uri is required") {
		path := uri.GetPath()
		assert.NotEmpty(t, path, "field 'uri.path' cannot be empty as this populates the target")
		// It should not use the old paths, but match the repo paths instead
		assert.False(t, strings.HasPrefix(path, "file:///workspace/source-code/"), "URI path should not have the workspace prefix")
	}

	if loc := dataSource.GetFileFindingLocationData(); assert.NotNil(t, loc, "FileFindingLocationData is required") {
		assert.Greater(t, loc.GetStartLine(), uint32(0), "field 'start_line' must be greater than 0")
		assert.GreaterOrEqual(t, loc.GetEndLine(), loc.GetStartLine(), "field 'end_line' must be >= 'start_line'")
	}

	switch dataSource.GetTargetType() {
	case ocsffindinginfo.DataSource_TARGET_TYPE_REPOSITORY:
		meta := dataSource.GetSourceCodeMetadata()
		if assert.NotNil(t, meta, "'source_code_metadata' is required for REPOSITORY") {
			assert.NotEmpty(t, meta.GetRepositoryUrl(), "field 'repository_url' is required for REPOSITORY")
			assert.NotEmpty(t, meta.GetReference(), "field 'reference' is required for REPOSITORY")
		}
	case ocsffindinginfo.DataSource_TARGET_TYPE_CONTAINER_IMAGE:
		meta := dataSource.GetOciPackageMetadata()
		if assert.NotNil(t, meta, "'oci_package_metadata' is required for CONTAINER_IMAGE") {
			assert.NotEmpty(t, meta.GetPackageUrl(), "field 'package_url' is required for CONTAINER_IMAGE")
			assert.NotEmpty(t, meta.GetTag(), "field 'tag' is required for CONTAINER_IMAGE")
		}
	case ocsffindinginfo.DataSource_TARGET_TYPE_WEBSITE:
		meta := dataSource.GetWebsiteMetadata()
		if assert.NotNil(t, meta, "'website_metadata' is required for WEBSITE") {
			assert.NotEmpty(t, meta.GetUrl(), "field 'url' is required for WEBSITE")
		}
	case ocsffindinginfo.DataSource_TARGET_TYPE_UNSPECIFIED:
		assert.Fail(t, "'target_type' cannot be UNSPECIFIED")
	default:
		assert.Fail(t, fmt.Sprintf("unhandled 'target_type': %s", dataSource.GetTargetType().String()))
	}

	vulnerabilities := finding.GetVulnerabilities()
	require.Len(t, vulnerabilities, 1, "Exactly one entry in 'Vulnerabilities' is required")
	vuln := vulnerabilities[0]
	require.NotNil(t, vuln, "Vulnerability entry cannot be nil")

	// Ideally, we'd always have at least one or the other, but currently a lot of the tools don't report them
	if cwe := vuln.GetCwe(); cwe != nil {
		assert.NotEmpty(t, cwe.GetUid(), "If a Cwe object exists, its Uid must be populated")
	}
	if cve := vuln.GetCve(); cve != nil {
		assert.NotEmpty(t, cve.GetUid(), "If a Cve object exists, its Uid must be populated")
	}

	acArray := vuln.GetAffectedCode()
	require.Len(t, acArray, 1, "Exactly one 'AffectedCode' is required for the vulnerability")
	ac := acArray[0]
	require.NotNil(t, ac, "'AffectedCode' entry cannot be nil")

	fileObject := ac.GetFile()
	if assert.NotNil(t, fileObject, "field 'AffectedCode.File' is required") {
		assert.NotEmpty(t, fileObject.GetName(), "the name/path for 'AffectedCode.File' is required")
	}
	assert.Greater(t, ac.GetStartLine(), int32(0), "field 'AffectedCode.StartLine' must be > 0")
	assert.GreaterOrEqual(t, ac.GetEndLine(), ac.GetStartLine(), "field 'AffectedCode.EndLine' must be >= 'StartLine'")

	return !t.Failed()
}

func AssertFindingListsMatch(t *testing.T, expectedFindings, actualFindings []*ocsf.VulnerabilityFinding) bool {
	// Helper function to create a unique key for a finding
	makeFindingKey := func(finding *ocsf.VulnerabilityFinding) string {
		uid := finding.GetFindingInfo().GetUid()
		// Use the first AffectedCode entry for the key
		ac := finding.GetVulnerabilities()[0].GetAffectedCode()[0]
		return fmt.Sprintf("%s|%s|L%d", uid, ac.GetFile().GetName(), ac.GetStartLine())
	}

	assert.Equal(t, len(expectedFindings), len(actualFindings), "Should have the same number of findings")

	expectedMap := make(map[string]*ocsf.VulnerabilityFinding)
	for _, f := range expectedFindings {
		key := makeFindingKey(f)
		expectedMap[key] = f
	}

	// Check each finding against the map
	for _, actual := range actualFindings {
		key := makeFindingKey(actual)
		if expected, ok := expectedMap[key]; ok {
			// Match found, compare the important fields
			t.Run(fmt.Sprintf("Comparing finding %s", key), func(t *testing.T) {
				assert.Equal(t, expected.GetFindingInfo().GetTitle(), actual.GetFindingInfo().GetTitle(), "Titles should match")

				var expectedDS, actualDS ocsffindinginfo.DataSource
				// Use require here because if JSON fails, the rest of the checks are invalid.
				require.NoError(t, protojson.Unmarshal([]byte(expected.GetFindingInfo().GetDataSources()[0]), &expectedDS), "Failed to unmarshal expected DataSource")
				require.NoError(t, protojson.Unmarshal([]byte(actual.GetFindingInfo().GetDataSources()[0]), &actualDS), "Failed to unmarshal actual DataSource")

				assert.Equal(t, expectedDS.GetTargetType(), actualDS.GetTargetType(), "DataSource TargetType should match")
				assert.Equal(t, expectedDS.GetUri().GetPath(), actualDS.GetUri().GetPath(), "DataSource Uri Path should match")

				// Compare location data
				expectedLoc := expectedDS.GetFileFindingLocationData()
				actualLoc := actualDS.GetFileFindingLocationData()
				if assert.NotNil(t, expectedLoc) && assert.NotNil(t, actualLoc) {
					assert.Equal(t, expectedLoc.GetStartLine(), actualLoc.GetStartLine(), "DataSource StartLine should match")
					assert.Equal(t, expectedLoc.GetEndLine(), actualLoc.GetEndLine(), "DataSource EndLine should match")
				}

				// Compare metadata based on type
				switch expectedDS.GetTargetType() {
				case ocsffindinginfo.DataSource_TARGET_TYPE_REPOSITORY:
					assert.Equal(t, expectedDS.GetSourceCodeMetadata().GetRepositoryUrl(), actualDS.GetSourceCodeMetadata().GetRepositoryUrl(), "Repository URL should match")
					assert.Equal(t, expectedDS.GetSourceCodeMetadata().GetReference(), actualDS.GetSourceCodeMetadata().GetReference(), "Repository Reference should match")
				case ocsffindinginfo.DataSource_TARGET_TYPE_CONTAINER_IMAGE:
					assert.Equal(t, expectedDS.GetOciPackageMetadata().GetPackageUrl(), actualDS.GetOciPackageMetadata().GetPackageUrl(), "OCI Package URL should match")
					assert.Equal(t, expectedDS.GetOciPackageMetadata().GetTag(), actualDS.GetOciPackageMetadata().GetTag(), "OCI Tag should match")
				case ocsffindinginfo.DataSource_TARGET_TYPE_WEBSITE:
					assert.Equal(t, expectedDS.GetWebsiteMetadata().GetUrl(), actualDS.GetWebsiteMetadata().GetUrl(), "Website URL should match")
				}

				expectedVuln := expected.GetVulnerabilities()[0]
				actualVuln := actual.GetVulnerabilities()[0]
				if expectedVuln.GetCwe() != nil || actualVuln.GetCwe() != nil {
					require.NotNil(t, expectedVuln.GetCwe(), "Expected CWE should not be nil if actual is not")
					require.NotNil(t, actualVuln.GetCwe(), "Actual CWE should not be nil if expected is not")
					assert.Equal(t, expectedVuln.GetCwe().GetUid(), actualVuln.GetCwe().GetUid(), "CWE Uid should match")
				}

				if expectedVuln.GetCve() != nil || actualVuln.GetCve() != nil {
					require.NotNil(t, expectedVuln.GetCve(), "Expected CVE should not be nil if actual is not")
					require.NotNil(t, actualVuln.GetCve(), "Actual CVE should not be nil if expected is not")
					assert.Equal(t, expectedVuln.GetCve().GetUid(), actualVuln.GetCve().GetUid(), "CVE Uid should match")
				}

				expectedAC := expectedVuln.GetAffectedCode()[0]
				actualAC := actualVuln.GetAffectedCode()[0]
				assert.Equal(t, expectedAC.GetEndLine(), actualAC.GetEndLine(), "AffectedCode EndLine should match")
			})
			// Remove from map to track which expected findings were seen
			delete(expectedMap, key)
		} else {
			assert.Fail(t, "Unexpected finding found in actual results", "Key: %s", key)
		}
	}

	// If any findings are left in the map, they were expected but not found
	for key := range expectedMap {
		assert.Fail(t, "Expected finding was not found in actual results", "Missing key: %s", key)
	}

	return !t.Failed()
}
