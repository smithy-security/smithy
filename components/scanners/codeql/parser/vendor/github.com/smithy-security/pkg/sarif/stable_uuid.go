package sarif

import (
	"bytes"
	"encoding/json"

	"github.com/go-errors/errors"
	"github.com/google/uuid"
	sarif "github.com/smithy-security/pkg/sarif/spec/gen/sarif-schema/v2-1-0"
	ocsf "github.com/smithy-security/smithy/sdk/gen/ocsf_schema/v1"
)

// StableUUIDProvider implementations should take an instance of a SARIF result
// extract various fields from it and uses them to provide a UUID5 ID to the
// result that is stable across scans for the same finding
type StableUUIDProvider interface {
	Generate(string, *sarif.Result) (string, error)
}

// FieldParser is a function that takes a SARIF result and returns one field
// from it as a byte slice or nil if that value is empty
type FieldParser func(res *sarif.Result) ([]byte, error)

// LocationParser uses the location of the result to generate bytes
func LocationParser(res *sarif.Result) ([]byte, error) {
	bb := bytes.NewBuffer([]byte{})
	for _, location := range res.Locations {
		jsonLocation, err := json.Marshal(location)
		if err != nil {
			return nil, errors.Errorf("could not extract bytes of result locations: %w", err)
		}
		bb.Write(jsonLocation)
	}

	return bb.Bytes(), nil
}

// RuleIDParser uses the bytes of the rule id and optionally the rule GUID to
// help generate the GUID of a result
func RuleIDParser(res *sarif.Result) ([]byte, error) {
	bb := bytes.NewBuffer([]byte{})

	var err error
	if res.RuleId != nil {
		_, err = bb.WriteString(*res.RuleId)
	} else if res.Rule != nil && res.Rule.Id != nil {
		_, err = bb.WriteString(*res.Rule.Id)
	} else if res.Rule != nil && res.Rule.Guid != nil {
		_, err = bb.WriteString(*res.Rule.Guid)
	}

	if err != nil {
		return nil, errors.Errorf("could not write rule id bytes to buffer: %w", err)
	}

	return bb.Bytes(), nil
}

// CweParserFunc returns a field parser that resolves the CWE of a result and
// returns the CWE ID as bytes of a lowercase string
func CweParserFunc(
	taxasByCWEID map[string]sarif.ReportingDescriptor,
	ruleToTools map[string]sarif.ReportingDescriptor,
) FieldParser {
	return func(res *sarif.Result) ([]byte, error) {
		ruleID := getRuleID(res)
		if ruleID == nil {
			return nil, errors.Errorf("could not extract rule id from result: %v", res)
		}

		var cve *ocsf.Cve
		var cwe *ocsf.Cwe

		rule, ok := ruleToTools[*ruleID]
		if !ok {
			goto get_cwe_bytes
		}

		if cve = extractCVE(rule); cve != nil {
			return json.Marshal(cve)
		}

	get_cwe_bytes:
		if cwe = extractCWE(*ruleID, taxasByCWEID, ruleToTools); cwe != nil {
			return json.Marshal(cwe)
		}

		return []byte{}, nil
	}
}

// StableUUIDBuilder is used to define the fields that will be used to generate
// a stable UUID5 for a SARIF result. The field extractors can be added to it
// and used to generate a instance of the StableUUIDProvider that has an
// immutable sequence of fields that will be used to generate the UUID. The
// sequence of the field extractors added to the builder will make a difference
// in the resulting UUID
type StableUUIDBuilder struct {
	fieldParsers []FieldParser
}

// NewStableUUIDBuilder returns an initialised version of the StableUUIDBuilder
func NewStableUUIDBuilder() StableUUIDBuilder {
	return StableUUIDBuilder{
		fieldParsers: []FieldParser{},
	}
}

// WithParser adds the field parser to the existing list of parsers and returns
// a new instance of the StableUUIDBuilder
func (s StableUUIDBuilder) WithParser(f FieldParser) StableUUIDBuilder {
	s.fieldParsers = append(s.fieldParsers, f)
	return s
}

// Build creates an immutable instance of the StableUUIDProvider that can be
// used to generate GUIDs from Sarif results that are missing their own
func (s StableUUIDBuilder) Build() StableUUIDProvider {
	return immutableStableUUIDProvider{
		fieldParsers: s.fieldParsers[:],
	}
}

type immutableStableUUIDProvider struct {
	fieldParsers []FieldParser
}

// String returns the string representation of the UUID5 generated by the data
// of the result
func (i immutableStableUUIDProvider) Generate(
	toolName string,
	res *sarif.Result,
) (string, error) {
	if res.Guid != nil {
		return *res.Guid, nil
	}

	bb := bytes.NewBuffer([]byte{})
	for _, parser := range i.fieldParsers {
		val, err := parser(res)
		if err != nil {
			return "", errors.Errorf("could not extract bytes from sarif result: %w", err)
		}

		if _, err := bb.Write(val); err != nil {
			return "", errors.Errorf("could not append bytes extracted from sarif result: %w", err)
		}
	}

	if bb.Len() == 0 {
		return "", errors.New("no bytes extracted from the sarif result")
	}

	if _, err := bb.WriteString(toolName); err != nil {
		return "", errors.Errorf("could not write tool name in the byte buffer: %w", err)
	}

	return uuid.NewSHA1(uuid.Nil, bb.Bytes()).String(), nil
}

// NewBasicStableUUIDProvider returns an instance of the StableUUIDBuilder
// set up with all the basic helpers
func NewBasicStableUUIDProvider() (StableUUIDProvider, error) {
	builder := NewStableUUIDBuilder().
		WithParser(LocationParser).
		WithParser(RuleIDParser).
		Build()
	return builder, nil
}
